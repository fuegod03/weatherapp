{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/jcdev/Projects/weatherapp/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _server = require('react-dom/server');\n\nvar _server2 = _interopRequireDefault(_server);\n\nvar _StaticRouter = require('react-router-dom/StaticRouter');\n\nvar _StaticRouter2 = _interopRequireDefault(_StaticRouter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n}\n\nvar Q = require('q');\n\nvar url = require('url');\n\nvar debug = require('debug')('react-ssr:serverRender');\n\nvar _require = require('react-router-config'),\n    matchRoutes = _require.matchRoutes,\n    renderRoutes = _require.renderRoutes;\n\nvar DefaultTemplate = require('./components/DefaultTemplate');\n\nvar findAllDataCalls = require('./helpers/findAllDataCalls');\n\nvar _require2 = require('./ssrContext'),\n    SSRProvider = _require2.SSRProvider;\n\nrequire('regenerator-runtime/runtime.js');\n\nvar fetchPageFromCache = function () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(redisClient, key) {\n    var data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = void 0;\n            _context.prev = 1;\n            _context.next = 4;\n            return redisClient.get(key);\n\n          case 4:\n            data = _context.sent;\n            _context.next = 10;\n            break;\n\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context['catch'](1);\n            console.warn('Failed to get cached page for ' + key);\n\n          case 10:\n            return _context.abrupt('return', data);\n\n          case 11:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, undefined, [[1, 7]]);\n  }));\n\n  return function fetchPageFromCache(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar storePageInCache = function () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(redisClient, key, data, cacheExpiry) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return redisClient.set(key, data, 'ex', cacheExpiry);\n\n          case 3:\n            _context2.next = 8;\n            break;\n\n          case 5:\n            _context2.prev = 5;\n            _context2.t0 = _context2['catch'](0);\n            console.warn('Failed to set cached page for ' + key);\n\n          case 8:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, undefined, [[0, 5]]);\n  }));\n\n  return function storePageInCache(_x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar serverRender = function () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(_ref3, req, res) {\n    var _ref3$Html = _ref3.Html,\n        Html = _ref3$Html === undefined ? DefaultTemplate : _ref3$Html,\n        _ref3$Providers = _ref3.Providers,\n        Providers = _ref3$Providers === undefined ? function (_ref5) {\n      var children = _ref5.children;\n      return _react2.default.createElement(_react.Fragment, null, children);\n    } : _ref3$Providers,\n        routes = _ref3.routes,\n        disable = _ref3.disable,\n        _ref3$ignore = _ref3.ignore,\n        ignore = _ref3$ignore === undefined ? [] : _ref3$ignore,\n        _ref3$cache = _ref3.cache,\n        cache = _ref3$cache === undefined ? {\n      mode: 'none',\n      duration: 1800,\n      redisClient: null,\n      keyPrefix: ''\n    } : _ref3$cache;\n\n    var urlWithoutQuery, html, _ref6, redisClient, extensionRegex, extension, hasRedis, safeToCache, key, cachedPage, context, state, matchedRoutes, lastRoute, parsedUrl, dataCalls, statusCode;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            urlWithoutQuery = req.url.split('?')[0];\n\n            if (!(disable || ignore.includes(urlWithoutQuery))) {\n              _context4.next = 4;\n              break;\n            }\n\n            html = _server2.default.renderToString(_react2.default.createElement(Html, null));\n            return _context4.abrupt('return', res.send('<!DOCTYPE html>' + html));\n\n          case 4:\n            _ref6 = cache || {}, redisClient = _ref6.redisClient;\n            extensionRegex = /(?:\\.([^.]+))?$/;\n            extension = extensionRegex.exec(urlWithoutQuery)[1];\n            hasRedis = redisClient && typeof redisClient.exists === 'function' && typeof redisClient.get === 'function';\n            safeToCache = req.useCacheForRequest;\n\n            if (!extension) {\n              _context4.next = 11;\n              break;\n            }\n\n            return _context4.abrupt('return', res.sendStatus(404));\n\n          case 11:\n            if (!(safeToCache && hasRedis && cache && cache.mode === 'full')) {\n              _context4.next = 22;\n              break;\n            }\n\n            key = '' + cache.keyPrefix + req.url;\n            _context4.next = 15;\n            return redisClient.exists(key);\n\n          case 15:\n            if (!_context4.sent) {\n              _context4.next = 22;\n              break;\n            }\n\n            _context4.next = 18;\n            return fetchPageFromCache(redisClient, key);\n\n          case 18:\n            cachedPage = _context4.sent;\n\n            if (!cachedPage) {\n              _context4.next = 22;\n              break;\n            }\n\n            if (cache.keyPrefix) {\n              res.set('X-Cache-Prefix', cache.keyPrefix);\n            }\n\n            return _context4.abrupt('return', res.status(200).send(cachedPage));\n\n          case 22:\n            context = {};\n            state = {}; // const component = props => renderRoutes(props.route.routes)\n            // const cleansedRoutes = [{ component, routes }]\n\n            matchedRoutes = matchRoutes(routes, urlWithoutQuery);\n            lastRoute = matchedRoutes[matchedRoutes.length - 1] || {};\n            parsedUrl = url.parse(req.url) || {};\n            dataCalls = findAllDataCalls(matchedRoutes, {\n              req: req,\n              res: res,\n              url: parsedUrl.pathname\n            });\n            statusCode = lastRoute && lastRoute.route && lastRoute.route.path && lastRoute.route.path.includes('*') ? 404 : 200;\n\n            if (!parsedUrl.pathname) {\n              debug('Parsed URL has no path name.');\n            }\n\n            debug('Routes? ', routes);\n            Q.allSettled(dataCalls).then(function () {\n              var _ref7 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee3(fetchedProps) {\n                var app, wrapper, page, status, _cache$duration, duration, _cache$keyPrefix, keyPrefix, _key;\n\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        debug('Fetched props... ', fetchedProps);\n                        fetchedProps = fetchedProps.map(function (prop) {\n                          return prop.value;\n                        });\n\n                        if (fetchedProps.length) {\n                          fetchedProps = fetchedProps.reduce(function (prop, props) {\n                            return _extends({}, props, prop);\n                          });\n                        }\n\n                        state._dataFromServerRender = fetchedProps;\n                        app = _server2.default.renderToString(_react2.default.createElement(SSRProvider, {\n                          value: fetchedProps\n                        }, _react2.default.createElement(Providers, null, _react2.default.createElement(_StaticRouter2.default, {\n                          location: req.url,\n                          context: context\n                        }, renderRoutes(routes)))));\n                        wrapper = _server2.default.renderToString(_react2.default.createElement(Html, {\n                          state: state\n                        }, app));\n                        page = '<!DOCTYPE html>' + wrapper;\n                        status = req.status || statusCode;\n\n                        if (!(safeToCache && hasRedis && cache && cache.mode === 'full' && status >= 200 && status < 300)) {\n                          _context3.next = 13;\n                          break;\n                        }\n\n                        _cache$duration = cache.duration, duration = _cache$duration === undefined ? 1800 : _cache$duration, _cache$keyPrefix = cache.keyPrefix, keyPrefix = _cache$keyPrefix === undefined ? '' : _cache$keyPrefix;\n                        _key = '' + keyPrefix + req.url;\n                        _context3.next = 13;\n                        return storePageInCache(redisClient, _key, page, duration);\n\n                      case 13:\n                        res.status(status).send(page);\n\n                      case 14:\n                      case 'end':\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3, undefined);\n              }));\n\n              return function (_x10) {\n                return _ref7.apply(this, arguments);\n              };\n            }()).catch(function (err) {\n              res.status(400).send('400: An error has occurred: ' + err);\n            });\n\n          case 32:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee4, undefined);\n  }));\n\n  return function serverRender(_x7, _x8, _x9) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.default = serverRender;","map":null,"metadata":{},"sourceType":"script"}